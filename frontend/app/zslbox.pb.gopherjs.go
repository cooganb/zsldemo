// Code generated by protoc-gen-gopherjs. DO NOT EDIT.
// source: zslbox.proto

/*
	Package zsl is a generated protocol buffer package.

	It is generated from these files:
		zslbox.proto

	It has these top-level messages:
		ShieldedInput
		Note
		ShieldedTransferRequest
		VerifyShieldedTransferRequest
		ShieldedTransfer
		VerifyShieldingRequest
		Shielding
		VerifyUnshieldingRequest
		Unshielding
		ZAddress
		Bytes
		Result
		Void
*/
package app

import jspb "github.com/johanbrandhorst/protobuf/jspb"

import (
	context "context"

	grpcweb "github.com/johanbrandhorst/protobuf/grpcweb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the jspb package it is being compiled against.
const _ = jspb.JspbPackageIsVersion2

// -------------------------------------------------------------------------------------------------
// Cross operation data structs
type ShieldedInput struct {
	Sk        []byte
	Rho       []byte
	Value     uint64
	TreeIndex uint64
	TreePath  [][]byte
}

// GetSk gets the Sk of the ShieldedInput.
func (m *ShieldedInput) GetSk() (x []byte) {
	if m == nil {
		return x
	}
	return m.Sk
}

// GetRho gets the Rho of the ShieldedInput.
func (m *ShieldedInput) GetRho() (x []byte) {
	if m == nil {
		return x
	}
	return m.Rho
}

// GetValue gets the Value of the ShieldedInput.
func (m *ShieldedInput) GetValue() (x uint64) {
	if m == nil {
		return x
	}
	return m.Value
}

// GetTreeIndex gets the TreeIndex of the ShieldedInput.
func (m *ShieldedInput) GetTreeIndex() (x uint64) {
	if m == nil {
		return x
	}
	return m.TreeIndex
}

// GetTreePath gets the TreePath of the ShieldedInput.
func (m *ShieldedInput) GetTreePath() (x [][]byte) {
	if m == nil {
		return x
	}
	return m.TreePath
}

// MarshalToWriter marshals ShieldedInput to the provided writer.
func (m *ShieldedInput) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Sk) > 0 {
		writer.WriteBytes(1, m.Sk)
	}

	if len(m.Rho) > 0 {
		writer.WriteBytes(2, m.Rho)
	}

	if m.Value != 0 {
		writer.WriteUint64(3, m.Value)
	}

	if m.TreeIndex != 0 {
		writer.WriteUint64(4, m.TreeIndex)
	}

	for _, val := range m.TreePath {
		writer.WriteBytes(5, val)
	}

	return
}

// Marshal marshals ShieldedInput to a slice of bytes.
func (m *ShieldedInput) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a ShieldedInput from the provided reader.
func (m *ShieldedInput) UnmarshalFromReader(reader jspb.Reader) *ShieldedInput {
	for reader.Next() {
		if m == nil {
			m = &ShieldedInput{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Sk = reader.ReadBytes()
		case 2:
			m.Rho = reader.ReadBytes()
		case 3:
			m.Value = reader.ReadUint64()
		case 4:
			m.TreeIndex = reader.ReadUint64()
		case 5:
			m.TreePath = append(m.TreePath, reader.ReadBytes())
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a ShieldedInput from a slice of bytes.
func (m *ShieldedInput) Unmarshal(rawBytes []byte) (*ShieldedInput, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type Note struct {
	Pk    []byte
	Rho   []byte
	Value uint64
}

// GetPk gets the Pk of the Note.
func (m *Note) GetPk() (x []byte) {
	if m == nil {
		return x
	}
	return m.Pk
}

// GetRho gets the Rho of the Note.
func (m *Note) GetRho() (x []byte) {
	if m == nil {
		return x
	}
	return m.Rho
}

// GetValue gets the Value of the Note.
func (m *Note) GetValue() (x uint64) {
	if m == nil {
		return x
	}
	return m.Value
}

// MarshalToWriter marshals Note to the provided writer.
func (m *Note) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Pk) > 0 {
		writer.WriteBytes(1, m.Pk)
	}

	if len(m.Rho) > 0 {
		writer.WriteBytes(2, m.Rho)
	}

	if m.Value != 0 {
		writer.WriteUint64(3, m.Value)
	}

	return
}

// Marshal marshals Note to a slice of bytes.
func (m *Note) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a Note from the provided reader.
func (m *Note) UnmarshalFromReader(reader jspb.Reader) *Note {
	for reader.Next() {
		if m == nil {
			m = &Note{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Pk = reader.ReadBytes()
		case 2:
			m.Rho = reader.ReadBytes()
		case 3:
			m.Value = reader.ReadUint64()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a Note from a slice of bytes.
func (m *Note) Unmarshal(rawBytes []byte) (*Note, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// -------------------------------------------------------------------------------------------------
// ShieldedTransfer data structs
// note: a shielded transfer has 2 inputs and 2 outputs (UTXO model)
type ShieldedTransferRequest struct {
	Inputs  []*ShieldedInput
	Outputs []*Note
}

// GetInputs gets the Inputs of the ShieldedTransferRequest.
func (m *ShieldedTransferRequest) GetInputs() (x []*ShieldedInput) {
	if m == nil {
		return x
	}
	return m.Inputs
}

// GetOutputs gets the Outputs of the ShieldedTransferRequest.
func (m *ShieldedTransferRequest) GetOutputs() (x []*Note) {
	if m == nil {
		return x
	}
	return m.Outputs
}

// MarshalToWriter marshals ShieldedTransferRequest to the provided writer.
func (m *ShieldedTransferRequest) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	for _, msg := range m.Inputs {
		writer.WriteMessage(1, func() {
			msg.MarshalToWriter(writer)
		})
	}

	for _, msg := range m.Outputs {
		writer.WriteMessage(2, func() {
			msg.MarshalToWriter(writer)
		})
	}

	return
}

// Marshal marshals ShieldedTransferRequest to a slice of bytes.
func (m *ShieldedTransferRequest) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a ShieldedTransferRequest from the provided reader.
func (m *ShieldedTransferRequest) UnmarshalFromReader(reader jspb.Reader) *ShieldedTransferRequest {
	for reader.Next() {
		if m == nil {
			m = &ShieldedTransferRequest{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			reader.ReadMessage(func() {
				m.Inputs = append(m.Inputs, new(ShieldedInput).UnmarshalFromReader(reader))
			})
		case 2:
			reader.ReadMessage(func() {
				m.Outputs = append(m.Outputs, new(Note).UnmarshalFromReader(reader))
			})
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a ShieldedTransferRequest from a slice of bytes.
func (m *ShieldedTransferRequest) Unmarshal(rawBytes []byte) (*ShieldedTransferRequest, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type VerifyShieldedTransferRequest struct {
	ShieldedTransfer *ShieldedTransfer
	TreeRoot         []byte
}

// GetShieldedTransfer gets the ShieldedTransfer of the VerifyShieldedTransferRequest.
func (m *VerifyShieldedTransferRequest) GetShieldedTransfer() (x *ShieldedTransfer) {
	if m == nil {
		return x
	}
	return m.ShieldedTransfer
}

// GetTreeRoot gets the TreeRoot of the VerifyShieldedTransferRequest.
func (m *VerifyShieldedTransferRequest) GetTreeRoot() (x []byte) {
	if m == nil {
		return x
	}
	return m.TreeRoot
}

// MarshalToWriter marshals VerifyShieldedTransferRequest to the provided writer.
func (m *VerifyShieldedTransferRequest) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.ShieldedTransfer != nil {
		writer.WriteMessage(1, func() {
			m.ShieldedTransfer.MarshalToWriter(writer)
		})
	}

	if len(m.TreeRoot) > 0 {
		writer.WriteBytes(2, m.TreeRoot)
	}

	return
}

// Marshal marshals VerifyShieldedTransferRequest to a slice of bytes.
func (m *VerifyShieldedTransferRequest) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a VerifyShieldedTransferRequest from the provided reader.
func (m *VerifyShieldedTransferRequest) UnmarshalFromReader(reader jspb.Reader) *VerifyShieldedTransferRequest {
	for reader.Next() {
		if m == nil {
			m = &VerifyShieldedTransferRequest{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			reader.ReadMessage(func() {
				m.ShieldedTransfer = m.ShieldedTransfer.UnmarshalFromReader(reader)
			})
		case 2:
			m.TreeRoot = reader.ReadBytes()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a VerifyShieldedTransferRequest from a slice of bytes.
func (m *VerifyShieldedTransferRequest) Unmarshal(rawBytes []byte) (*VerifyShieldedTransferRequest, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type ShieldedTransfer struct {
	Snark []byte
	// input spend nullifiers
	SpendNullifiers [][]byte
	// output send nullifiers & commitments
	SendNullifiers [][]byte
	Commitments    [][]byte
}

// GetSnark gets the Snark of the ShieldedTransfer.
func (m *ShieldedTransfer) GetSnark() (x []byte) {
	if m == nil {
		return x
	}
	return m.Snark
}

// GetSpendNullifiers gets the SpendNullifiers of the ShieldedTransfer.
func (m *ShieldedTransfer) GetSpendNullifiers() (x [][]byte) {
	if m == nil {
		return x
	}
	return m.SpendNullifiers
}

// GetSendNullifiers gets the SendNullifiers of the ShieldedTransfer.
func (m *ShieldedTransfer) GetSendNullifiers() (x [][]byte) {
	if m == nil {
		return x
	}
	return m.SendNullifiers
}

// GetCommitments gets the Commitments of the ShieldedTransfer.
func (m *ShieldedTransfer) GetCommitments() (x [][]byte) {
	if m == nil {
		return x
	}
	return m.Commitments
}

// MarshalToWriter marshals ShieldedTransfer to the provided writer.
func (m *ShieldedTransfer) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Snark) > 0 {
		writer.WriteBytes(1, m.Snark)
	}

	for _, val := range m.SpendNullifiers {
		writer.WriteBytes(2, val)
	}

	for _, val := range m.SendNullifiers {
		writer.WriteBytes(3, val)
	}

	for _, val := range m.Commitments {
		writer.WriteBytes(4, val)
	}

	return
}

// Marshal marshals ShieldedTransfer to a slice of bytes.
func (m *ShieldedTransfer) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a ShieldedTransfer from the provided reader.
func (m *ShieldedTransfer) UnmarshalFromReader(reader jspb.Reader) *ShieldedTransfer {
	for reader.Next() {
		if m == nil {
			m = &ShieldedTransfer{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Snark = reader.ReadBytes()
		case 2:
			m.SpendNullifiers = append(m.SpendNullifiers, reader.ReadBytes())
		case 3:
			m.SendNullifiers = append(m.SendNullifiers, reader.ReadBytes())
		case 4:
			m.Commitments = append(m.Commitments, reader.ReadBytes())
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a ShieldedTransfer from a slice of bytes.
func (m *ShieldedTransfer) Unmarshal(rawBytes []byte) (*ShieldedTransfer, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// -------------------------------------------------------------------------------------------------
// Shielding data structs
type VerifyShieldingRequest struct {
	Shielding *Shielding
	Value     uint64
}

// GetShielding gets the Shielding of the VerifyShieldingRequest.
func (m *VerifyShieldingRequest) GetShielding() (x *Shielding) {
	if m == nil {
		return x
	}
	return m.Shielding
}

// GetValue gets the Value of the VerifyShieldingRequest.
func (m *VerifyShieldingRequest) GetValue() (x uint64) {
	if m == nil {
		return x
	}
	return m.Value
}

// MarshalToWriter marshals VerifyShieldingRequest to the provided writer.
func (m *VerifyShieldingRequest) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.Shielding != nil {
		writer.WriteMessage(1, func() {
			m.Shielding.MarshalToWriter(writer)
		})
	}

	if m.Value != 0 {
		writer.WriteUint64(2, m.Value)
	}

	return
}

// Marshal marshals VerifyShieldingRequest to a slice of bytes.
func (m *VerifyShieldingRequest) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a VerifyShieldingRequest from the provided reader.
func (m *VerifyShieldingRequest) UnmarshalFromReader(reader jspb.Reader) *VerifyShieldingRequest {
	for reader.Next() {
		if m == nil {
			m = &VerifyShieldingRequest{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			reader.ReadMessage(func() {
				m.Shielding = m.Shielding.UnmarshalFromReader(reader)
			})
		case 2:
			m.Value = reader.ReadUint64()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a VerifyShieldingRequest from a slice of bytes.
func (m *VerifyShieldingRequest) Unmarshal(rawBytes []byte) (*VerifyShieldingRequest, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type Shielding struct {
	Snark         []byte
	Commitment    []byte
	SendNullifier []byte
}

// GetSnark gets the Snark of the Shielding.
func (m *Shielding) GetSnark() (x []byte) {
	if m == nil {
		return x
	}
	return m.Snark
}

// GetCommitment gets the Commitment of the Shielding.
func (m *Shielding) GetCommitment() (x []byte) {
	if m == nil {
		return x
	}
	return m.Commitment
}

// GetSendNullifier gets the SendNullifier of the Shielding.
func (m *Shielding) GetSendNullifier() (x []byte) {
	if m == nil {
		return x
	}
	return m.SendNullifier
}

// MarshalToWriter marshals Shielding to the provided writer.
func (m *Shielding) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Snark) > 0 {
		writer.WriteBytes(1, m.Snark)
	}

	if len(m.Commitment) > 0 {
		writer.WriteBytes(2, m.Commitment)
	}

	if len(m.SendNullifier) > 0 {
		writer.WriteBytes(3, m.SendNullifier)
	}

	return
}

// Marshal marshals Shielding to a slice of bytes.
func (m *Shielding) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a Shielding from the provided reader.
func (m *Shielding) UnmarshalFromReader(reader jspb.Reader) *Shielding {
	for reader.Next() {
		if m == nil {
			m = &Shielding{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Snark = reader.ReadBytes()
		case 2:
			m.Commitment = reader.ReadBytes()
		case 3:
			m.SendNullifier = reader.ReadBytes()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a Shielding from a slice of bytes.
func (m *Shielding) Unmarshal(rawBytes []byte) (*Shielding, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// -------------------------------------------------------------------------------------------------
// Unshielding data structs
type VerifyUnshieldingRequest struct {
	Snark          []byte
	SpendNullifier []byte
	TreeRoot       []byte
	Value          uint64
}

// GetSnark gets the Snark of the VerifyUnshieldingRequest.
func (m *VerifyUnshieldingRequest) GetSnark() (x []byte) {
	if m == nil {
		return x
	}
	return m.Snark
}

// GetSpendNullifier gets the SpendNullifier of the VerifyUnshieldingRequest.
func (m *VerifyUnshieldingRequest) GetSpendNullifier() (x []byte) {
	if m == nil {
		return x
	}
	return m.SpendNullifier
}

// GetTreeRoot gets the TreeRoot of the VerifyUnshieldingRequest.
func (m *VerifyUnshieldingRequest) GetTreeRoot() (x []byte) {
	if m == nil {
		return x
	}
	return m.TreeRoot
}

// GetValue gets the Value of the VerifyUnshieldingRequest.
func (m *VerifyUnshieldingRequest) GetValue() (x uint64) {
	if m == nil {
		return x
	}
	return m.Value
}

// MarshalToWriter marshals VerifyUnshieldingRequest to the provided writer.
func (m *VerifyUnshieldingRequest) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Snark) > 0 {
		writer.WriteBytes(1, m.Snark)
	}

	if len(m.SpendNullifier) > 0 {
		writer.WriteBytes(2, m.SpendNullifier)
	}

	if len(m.TreeRoot) > 0 {
		writer.WriteBytes(3, m.TreeRoot)
	}

	if m.Value != 0 {
		writer.WriteUint64(4, m.Value)
	}

	return
}

// Marshal marshals VerifyUnshieldingRequest to a slice of bytes.
func (m *VerifyUnshieldingRequest) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a VerifyUnshieldingRequest from the provided reader.
func (m *VerifyUnshieldingRequest) UnmarshalFromReader(reader jspb.Reader) *VerifyUnshieldingRequest {
	for reader.Next() {
		if m == nil {
			m = &VerifyUnshieldingRequest{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Snark = reader.ReadBytes()
		case 2:
			m.SpendNullifier = reader.ReadBytes()
		case 3:
			m.TreeRoot = reader.ReadBytes()
		case 4:
			m.Value = reader.ReadUint64()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a VerifyUnshieldingRequest from a slice of bytes.
func (m *VerifyUnshieldingRequest) Unmarshal(rawBytes []byte) (*VerifyUnshieldingRequest, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type Unshielding struct {
	Snark          []byte
	SpendNullifier []byte
	SendNullifier  []byte
}

// GetSnark gets the Snark of the Unshielding.
func (m *Unshielding) GetSnark() (x []byte) {
	if m == nil {
		return x
	}
	return m.Snark
}

// GetSpendNullifier gets the SpendNullifier of the Unshielding.
func (m *Unshielding) GetSpendNullifier() (x []byte) {
	if m == nil {
		return x
	}
	return m.SpendNullifier
}

// GetSendNullifier gets the SendNullifier of the Unshielding.
func (m *Unshielding) GetSendNullifier() (x []byte) {
	if m == nil {
		return x
	}
	return m.SendNullifier
}

// MarshalToWriter marshals Unshielding to the provided writer.
func (m *Unshielding) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Snark) > 0 {
		writer.WriteBytes(1, m.Snark)
	}

	if len(m.SpendNullifier) > 0 {
		writer.WriteBytes(2, m.SpendNullifier)
	}

	if len(m.SendNullifier) > 0 {
		writer.WriteBytes(3, m.SendNullifier)
	}

	return
}

// Marshal marshals Unshielding to a slice of bytes.
func (m *Unshielding) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a Unshielding from the provided reader.
func (m *Unshielding) UnmarshalFromReader(reader jspb.Reader) *Unshielding {
	for reader.Next() {
		if m == nil {
			m = &Unshielding{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Snark = reader.ReadBytes()
		case 2:
			m.SpendNullifier = reader.ReadBytes()
		case 3:
			m.SendNullifier = reader.ReadBytes()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a Unshielding from a slice of bytes.
func (m *Unshielding) Unmarshal(rawBytes []byte) (*Unshielding, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// -------------------------------------------------------------------------------------------------
// Other
type ZAddress struct {
	Sk []byte
	Pk []byte
}

// GetSk gets the Sk of the ZAddress.
func (m *ZAddress) GetSk() (x []byte) {
	if m == nil {
		return x
	}
	return m.Sk
}

// GetPk gets the Pk of the ZAddress.
func (m *ZAddress) GetPk() (x []byte) {
	if m == nil {
		return x
	}
	return m.Pk
}

// MarshalToWriter marshals ZAddress to the provided writer.
func (m *ZAddress) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Sk) > 0 {
		writer.WriteBytes(1, m.Sk)
	}

	if len(m.Pk) > 0 {
		writer.WriteBytes(2, m.Pk)
	}

	return
}

// Marshal marshals ZAddress to a slice of bytes.
func (m *ZAddress) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a ZAddress from the provided reader.
func (m *ZAddress) UnmarshalFromReader(reader jspb.Reader) *ZAddress {
	for reader.Next() {
		if m == nil {
			m = &ZAddress{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Sk = reader.ReadBytes()
		case 2:
			m.Pk = reader.ReadBytes()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a ZAddress from a slice of bytes.
func (m *ZAddress) Unmarshal(rawBytes []byte) (*ZAddress, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type Bytes struct {
	Bytes []byte
}

// GetBytes gets the Bytes of the Bytes.
func (m *Bytes) GetBytes() (x []byte) {
	if m == nil {
		return x
	}
	return m.Bytes
}

// MarshalToWriter marshals Bytes to the provided writer.
func (m *Bytes) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Bytes) > 0 {
		writer.WriteBytes(1, m.Bytes)
	}

	return
}

// Marshal marshals Bytes to a slice of bytes.
func (m *Bytes) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a Bytes from the provided reader.
func (m *Bytes) UnmarshalFromReader(reader jspb.Reader) *Bytes {
	for reader.Next() {
		if m == nil {
			m = &Bytes{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Bytes = reader.ReadBytes()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a Bytes from a slice of bytes.
func (m *Bytes) Unmarshal(rawBytes []byte) (*Bytes, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type Result struct {
	Result  bool
	Message string
}

// GetResult gets the Result of the Result.
func (m *Result) GetResult() (x bool) {
	if m == nil {
		return x
	}
	return m.Result
}

// GetMessage gets the Message of the Result.
func (m *Result) GetMessage() (x string) {
	if m == nil {
		return x
	}
	return m.Message
}

// MarshalToWriter marshals Result to the provided writer.
func (m *Result) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.Result {
		writer.WriteBool(1, m.Result)
	}

	if len(m.Message) > 0 {
		writer.WriteString(2, m.Message)
	}

	return
}

// Marshal marshals Result to a slice of bytes.
func (m *Result) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a Result from the provided reader.
func (m *Result) UnmarshalFromReader(reader jspb.Reader) *Result {
	for reader.Next() {
		if m == nil {
			m = &Result{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Result = reader.ReadBool()
		case 2:
			m.Message = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a Result from a slice of bytes.
func (m *Result) Unmarshal(rawBytes []byte) (*Result, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type Void struct {
}

// MarshalToWriter marshals Void to the provided writer.
func (m *Void) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	return
}

// Marshal marshals Void to a slice of bytes.
func (m *Void) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a Void from the provided reader.
func (m *Void) UnmarshalFromReader(reader jspb.Reader) *Void {
	for reader.Next() {
		if m == nil {
			m = &Void{}
		}

		switch reader.GetFieldNumber() {
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a Void from a slice of bytes.
func (m *Void) Unmarshal(rawBytes []byte) (*Void, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpcweb.Client

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpcweb package it is being compiled against.
const _ = grpcweb.GrpcWebPackageIsVersion3

// Client API for ZSLBox service

//
// Provides services to compute and verify proofs
// for shielding, unshielding and shielded transfer
// operations
type ZSLBoxClient interface {
	// CreateShielding computes a zkSNARK and a note commitment for given note.
	// Also returns a sendNullifier to ensure note.Rho (random) is unique
	CreateShielding(ctx context.Context, in *Note, opts ...grpcweb.CallOption) (*Shielding, error)
	// CreateUnshielding computes a zkSNARK, nullifiers for given input, using Unshielding circuit
	CreateUnshielding(ctx context.Context, in *ShieldedInput, opts ...grpcweb.CallOption) (*Unshielding, error)
	// CreateShieldedTransfer takes 2 notes as inputs (known Sk) and 2 desired output notes.
	// It returns the zkSNARK, the spend nullifiers for the inputs, and the commitments & send nullifiers for outputs
	CreateShieldedTransfer(ctx context.Context, in *ShieldedTransferRequest, opts ...grpcweb.CallOption) (*ShieldedTransfer, error)
	// VerifyShielding ensures that the provided Shielding proof is valid. It takes as input the zkSNARK,
	// the send nullifier, commitment and value of the shielded note.
	VerifyShielding(ctx context.Context, in *VerifyShieldingRequest, opts ...grpcweb.CallOption) (*Result, error)
	// VerifyUnshielding ensures that the provided Unshielding proof is valid. It takes as input the zkSNARK,
	// the spend nullifier, the tree root and value of the shielded note.
	VerifyUnshielding(ctx context.Context, in *VerifyUnshieldingRequest, opts ...grpcweb.CallOption) (*Result, error)
	// VerifyShieldedTransfer ensures that the provided shielded transfer proof is valid.
	// It takes as input the zkSNARK, treeRoot, spend nullifiers for inputs and send nullifiers & commitments
	// for outputs
	VerifyShieldedTransfer(ctx context.Context, in *VerifyShieldedTransferRequest, opts ...grpcweb.CallOption) (*Result, error)
	// GetCommitment returns SHA256(note.Rho || note.Pk || note.Value)
	// where note.Value is in little endian byte order
	GetCommitment(ctx context.Context, in *Note, opts ...grpcweb.CallOption) (*Bytes, error)
	// GetSendNullifier returns SHA256(0x00 || note.Rho)
	GetSendNullifier(ctx context.Context, in *Note, opts ...grpcweb.CallOption) (*Bytes, error)
	// GetSpendNullifier returns SHA256(0x01 || shieldedInput.Rho || shieldedInput.Sk)
	GetSpendNullifier(ctx context.Context, in *ShieldedInput, opts ...grpcweb.CallOption) (*Bytes, error)
	// GetNewAddress returns a tuple (Pk, Sk) where Pk is the paying (public) key and Sk is the secret key
	GetNewAddress(ctx context.Context, in *Void, opts ...grpcweb.CallOption) (*ZAddress, error)
	// Sha256Compress applies SHA-256 to one input block, excluding the padding step specified in [NIST2015, Section 5.1]
	Sha256Compress(ctx context.Context, in *Bytes, opts ...grpcweb.CallOption) (*Bytes, error)
}

type zSLBoxClient struct {
	client *grpcweb.Client
}

// NewZSLBoxClient creates a new gRPC-Web client.
func NewZSLBoxClient(hostname string, opts ...grpcweb.DialOption) ZSLBoxClient {
	return &zSLBoxClient{
		client: grpcweb.NewClient(hostname, "zsl.ZSLBox", opts...),
	}
}

func (c *zSLBoxClient) CreateShielding(ctx context.Context, in *Note, opts ...grpcweb.CallOption) (*Shielding, error) {
	resp, err := c.client.RPCCall(ctx, "CreateShielding", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Shielding).Unmarshal(resp)
}

func (c *zSLBoxClient) CreateUnshielding(ctx context.Context, in *ShieldedInput, opts ...grpcweb.CallOption) (*Unshielding, error) {
	resp, err := c.client.RPCCall(ctx, "CreateUnshielding", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Unshielding).Unmarshal(resp)
}

func (c *zSLBoxClient) CreateShieldedTransfer(ctx context.Context, in *ShieldedTransferRequest, opts ...grpcweb.CallOption) (*ShieldedTransfer, error) {
	resp, err := c.client.RPCCall(ctx, "CreateShieldedTransfer", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(ShieldedTransfer).Unmarshal(resp)
}

func (c *zSLBoxClient) VerifyShielding(ctx context.Context, in *VerifyShieldingRequest, opts ...grpcweb.CallOption) (*Result, error) {
	resp, err := c.client.RPCCall(ctx, "VerifyShielding", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Result).Unmarshal(resp)
}

func (c *zSLBoxClient) VerifyUnshielding(ctx context.Context, in *VerifyUnshieldingRequest, opts ...grpcweb.CallOption) (*Result, error) {
	resp, err := c.client.RPCCall(ctx, "VerifyUnshielding", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Result).Unmarshal(resp)
}

func (c *zSLBoxClient) VerifyShieldedTransfer(ctx context.Context, in *VerifyShieldedTransferRequest, opts ...grpcweb.CallOption) (*Result, error) {
	resp, err := c.client.RPCCall(ctx, "VerifyShieldedTransfer", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Result).Unmarshal(resp)
}

func (c *zSLBoxClient) GetCommitment(ctx context.Context, in *Note, opts ...grpcweb.CallOption) (*Bytes, error) {
	resp, err := c.client.RPCCall(ctx, "GetCommitment", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Bytes).Unmarshal(resp)
}

func (c *zSLBoxClient) GetSendNullifier(ctx context.Context, in *Note, opts ...grpcweb.CallOption) (*Bytes, error) {
	resp, err := c.client.RPCCall(ctx, "GetSendNullifier", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Bytes).Unmarshal(resp)
}

func (c *zSLBoxClient) GetSpendNullifier(ctx context.Context, in *ShieldedInput, opts ...grpcweb.CallOption) (*Bytes, error) {
	resp, err := c.client.RPCCall(ctx, "GetSpendNullifier", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Bytes).Unmarshal(resp)
}

func (c *zSLBoxClient) GetNewAddress(ctx context.Context, in *Void, opts ...grpcweb.CallOption) (*ZAddress, error) {
	resp, err := c.client.RPCCall(ctx, "GetNewAddress", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(ZAddress).Unmarshal(resp)
}

func (c *zSLBoxClient) Sha256Compress(ctx context.Context, in *Bytes, opts ...grpcweb.CallOption) (*Bytes, error) {
	resp, err := c.client.RPCCall(ctx, "Sha256Compress", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Bytes).Unmarshal(resp)
}
