// Code generated by protoc-gen-go. DO NOT EDIT.
// source: zslbox.proto

/*
Package zsl is a generated protocol buffer package.

It is generated from these files:
	zslbox.proto

It has these top-level messages:
	ShieldedInput
	Note
	ShieldedTransferRequest
	VerifyShieldedTransferRequest
	ShieldedTransfer
	VerifyShieldingRequest
	Shielding
	VerifyUnshieldingRequest
	Unshielding
	ZAddress
	Bytes
	Result
	Void
*/
package zsl

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// -------------------------------------------------------------------------------------------------
// Cross operation data structs
type ShieldedInput struct {
	Sk        []byte   `protobuf:"bytes,1,opt,name=sk,proto3" json:"sk,omitempty"`
	Rho       []byte   `protobuf:"bytes,2,opt,name=rho,proto3" json:"rho,omitempty"`
	Value     uint64   `protobuf:"varint,3,opt,name=value" json:"value,omitempty"`
	TreeIndex uint64   `protobuf:"varint,4,opt,name=treeIndex" json:"treeIndex,omitempty"`
	TreePath  [][]byte `protobuf:"bytes,5,rep,name=treePath,proto3" json:"treePath,omitempty"`
}

func (m *ShieldedInput) Reset()                    { *m = ShieldedInput{} }
func (m *ShieldedInput) String() string            { return proto.CompactTextString(m) }
func (*ShieldedInput) ProtoMessage()               {}
func (*ShieldedInput) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ShieldedInput) GetSk() []byte {
	if m != nil {
		return m.Sk
	}
	return nil
}

func (m *ShieldedInput) GetRho() []byte {
	if m != nil {
		return m.Rho
	}
	return nil
}

func (m *ShieldedInput) GetValue() uint64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *ShieldedInput) GetTreeIndex() uint64 {
	if m != nil {
		return m.TreeIndex
	}
	return 0
}

func (m *ShieldedInput) GetTreePath() [][]byte {
	if m != nil {
		return m.TreePath
	}
	return nil
}

type Note struct {
	Pk    []byte `protobuf:"bytes,1,opt,name=pk,proto3" json:"pk,omitempty"`
	Rho   []byte `protobuf:"bytes,2,opt,name=rho,proto3" json:"rho,omitempty"`
	Value uint64 `protobuf:"varint,3,opt,name=value" json:"value,omitempty"`
}

func (m *Note) Reset()                    { *m = Note{} }
func (m *Note) String() string            { return proto.CompactTextString(m) }
func (*Note) ProtoMessage()               {}
func (*Note) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Note) GetPk() []byte {
	if m != nil {
		return m.Pk
	}
	return nil
}

func (m *Note) GetRho() []byte {
	if m != nil {
		return m.Rho
	}
	return nil
}

func (m *Note) GetValue() uint64 {
	if m != nil {
		return m.Value
	}
	return 0
}

// -------------------------------------------------------------------------------------------------
// ShieldedTransfer data structs
// note: a shielded transfer has 2 inputs and 2 outputs (UTXO model)
type ShieldedTransferRequest struct {
	Inputs  []*ShieldedInput `protobuf:"bytes,1,rep,name=inputs" json:"inputs,omitempty"`
	Outputs []*Note          `protobuf:"bytes,2,rep,name=outputs" json:"outputs,omitempty"`
}

func (m *ShieldedTransferRequest) Reset()                    { *m = ShieldedTransferRequest{} }
func (m *ShieldedTransferRequest) String() string            { return proto.CompactTextString(m) }
func (*ShieldedTransferRequest) ProtoMessage()               {}
func (*ShieldedTransferRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *ShieldedTransferRequest) GetInputs() []*ShieldedInput {
	if m != nil {
		return m.Inputs
	}
	return nil
}

func (m *ShieldedTransferRequest) GetOutputs() []*Note {
	if m != nil {
		return m.Outputs
	}
	return nil
}

type VerifyShieldedTransferRequest struct {
	ShieldedTransfer *ShieldedTransfer `protobuf:"bytes,1,opt,name=shieldedTransfer" json:"shieldedTransfer,omitempty"`
	TreeRoot         []byte            `protobuf:"bytes,2,opt,name=treeRoot,proto3" json:"treeRoot,omitempty"`
}

func (m *VerifyShieldedTransferRequest) Reset()                    { *m = VerifyShieldedTransferRequest{} }
func (m *VerifyShieldedTransferRequest) String() string            { return proto.CompactTextString(m) }
func (*VerifyShieldedTransferRequest) ProtoMessage()               {}
func (*VerifyShieldedTransferRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *VerifyShieldedTransferRequest) GetShieldedTransfer() *ShieldedTransfer {
	if m != nil {
		return m.ShieldedTransfer
	}
	return nil
}

func (m *VerifyShieldedTransferRequest) GetTreeRoot() []byte {
	if m != nil {
		return m.TreeRoot
	}
	return nil
}

type ShieldedTransfer struct {
	Snark []byte `protobuf:"bytes,1,opt,name=snark,proto3" json:"snark,omitempty"`
	// input spend nullifiers
	SpendNullifiers [][]byte `protobuf:"bytes,2,rep,name=spendNullifiers,proto3" json:"spendNullifiers,omitempty"`
	// output send nullifiers & commitments
	SendNullifiers [][]byte `protobuf:"bytes,3,rep,name=sendNullifiers,proto3" json:"sendNullifiers,omitempty"`
	Commitments    [][]byte `protobuf:"bytes,4,rep,name=commitments,proto3" json:"commitments,omitempty"`
}

func (m *ShieldedTransfer) Reset()                    { *m = ShieldedTransfer{} }
func (m *ShieldedTransfer) String() string            { return proto.CompactTextString(m) }
func (*ShieldedTransfer) ProtoMessage()               {}
func (*ShieldedTransfer) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *ShieldedTransfer) GetSnark() []byte {
	if m != nil {
		return m.Snark
	}
	return nil
}

func (m *ShieldedTransfer) GetSpendNullifiers() [][]byte {
	if m != nil {
		return m.SpendNullifiers
	}
	return nil
}

func (m *ShieldedTransfer) GetSendNullifiers() [][]byte {
	if m != nil {
		return m.SendNullifiers
	}
	return nil
}

func (m *ShieldedTransfer) GetCommitments() [][]byte {
	if m != nil {
		return m.Commitments
	}
	return nil
}

// -------------------------------------------------------------------------------------------------
// Shielding data structs
type VerifyShieldingRequest struct {
	Shielding *Shielding `protobuf:"bytes,1,opt,name=shielding" json:"shielding,omitempty"`
	Value     uint64     `protobuf:"varint,2,opt,name=value" json:"value,omitempty"`
}

func (m *VerifyShieldingRequest) Reset()                    { *m = VerifyShieldingRequest{} }
func (m *VerifyShieldingRequest) String() string            { return proto.CompactTextString(m) }
func (*VerifyShieldingRequest) ProtoMessage()               {}
func (*VerifyShieldingRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *VerifyShieldingRequest) GetShielding() *Shielding {
	if m != nil {
		return m.Shielding
	}
	return nil
}

func (m *VerifyShieldingRequest) GetValue() uint64 {
	if m != nil {
		return m.Value
	}
	return 0
}

type Shielding struct {
	Snark         []byte `protobuf:"bytes,1,opt,name=snark,proto3" json:"snark,omitempty"`
	Commitment    []byte `protobuf:"bytes,2,opt,name=commitment,proto3" json:"commitment,omitempty"`
	SendNullifier []byte `protobuf:"bytes,3,opt,name=sendNullifier,proto3" json:"sendNullifier,omitempty"`
}

func (m *Shielding) Reset()                    { *m = Shielding{} }
func (m *Shielding) String() string            { return proto.CompactTextString(m) }
func (*Shielding) ProtoMessage()               {}
func (*Shielding) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Shielding) GetSnark() []byte {
	if m != nil {
		return m.Snark
	}
	return nil
}

func (m *Shielding) GetCommitment() []byte {
	if m != nil {
		return m.Commitment
	}
	return nil
}

func (m *Shielding) GetSendNullifier() []byte {
	if m != nil {
		return m.SendNullifier
	}
	return nil
}

// -------------------------------------------------------------------------------------------------
// Unshielding data structs
type VerifyUnshieldingRequest struct {
	Snark          []byte `protobuf:"bytes,1,opt,name=snark,proto3" json:"snark,omitempty"`
	SpendNullifier []byte `protobuf:"bytes,2,opt,name=spendNullifier,proto3" json:"spendNullifier,omitempty"`
	TreeRoot       []byte `protobuf:"bytes,3,opt,name=treeRoot,proto3" json:"treeRoot,omitempty"`
	Value          uint64 `protobuf:"varint,4,opt,name=value" json:"value,omitempty"`
}

func (m *VerifyUnshieldingRequest) Reset()                    { *m = VerifyUnshieldingRequest{} }
func (m *VerifyUnshieldingRequest) String() string            { return proto.CompactTextString(m) }
func (*VerifyUnshieldingRequest) ProtoMessage()               {}
func (*VerifyUnshieldingRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *VerifyUnshieldingRequest) GetSnark() []byte {
	if m != nil {
		return m.Snark
	}
	return nil
}

func (m *VerifyUnshieldingRequest) GetSpendNullifier() []byte {
	if m != nil {
		return m.SpendNullifier
	}
	return nil
}

func (m *VerifyUnshieldingRequest) GetTreeRoot() []byte {
	if m != nil {
		return m.TreeRoot
	}
	return nil
}

func (m *VerifyUnshieldingRequest) GetValue() uint64 {
	if m != nil {
		return m.Value
	}
	return 0
}

type Unshielding struct {
	Snark          []byte `protobuf:"bytes,1,opt,name=snark,proto3" json:"snark,omitempty"`
	SpendNullifier []byte `protobuf:"bytes,2,opt,name=spendNullifier,proto3" json:"spendNullifier,omitempty"`
	SendNullifier  []byte `protobuf:"bytes,3,opt,name=sendNullifier,proto3" json:"sendNullifier,omitempty"`
}

func (m *Unshielding) Reset()                    { *m = Unshielding{} }
func (m *Unshielding) String() string            { return proto.CompactTextString(m) }
func (*Unshielding) ProtoMessage()               {}
func (*Unshielding) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *Unshielding) GetSnark() []byte {
	if m != nil {
		return m.Snark
	}
	return nil
}

func (m *Unshielding) GetSpendNullifier() []byte {
	if m != nil {
		return m.SpendNullifier
	}
	return nil
}

func (m *Unshielding) GetSendNullifier() []byte {
	if m != nil {
		return m.SendNullifier
	}
	return nil
}

// -------------------------------------------------------------------------------------------------
// Other
type ZAddress struct {
	Sk []byte `protobuf:"bytes,1,opt,name=sk,proto3" json:"sk,omitempty"`
	Pk []byte `protobuf:"bytes,2,opt,name=pk,proto3" json:"pk,omitempty"`
}

func (m *ZAddress) Reset()                    { *m = ZAddress{} }
func (m *ZAddress) String() string            { return proto.CompactTextString(m) }
func (*ZAddress) ProtoMessage()               {}
func (*ZAddress) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *ZAddress) GetSk() []byte {
	if m != nil {
		return m.Sk
	}
	return nil
}

func (m *ZAddress) GetPk() []byte {
	if m != nil {
		return m.Pk
	}
	return nil
}

type Bytes struct {
	Bytes []byte `protobuf:"bytes,1,opt,name=bytes,proto3" json:"bytes,omitempty"`
}

func (m *Bytes) Reset()                    { *m = Bytes{} }
func (m *Bytes) String() string            { return proto.CompactTextString(m) }
func (*Bytes) ProtoMessage()               {}
func (*Bytes) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *Bytes) GetBytes() []byte {
	if m != nil {
		return m.Bytes
	}
	return nil
}

type Result struct {
	Result  bool   `protobuf:"varint,1,opt,name=result" json:"result,omitempty"`
	Message string `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
}

func (m *Result) Reset()                    { *m = Result{} }
func (m *Result) String() string            { return proto.CompactTextString(m) }
func (*Result) ProtoMessage()               {}
func (*Result) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *Result) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *Result) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type Void struct {
}

func (m *Void) Reset()                    { *m = Void{} }
func (m *Void) String() string            { return proto.CompactTextString(m) }
func (*Void) ProtoMessage()               {}
func (*Void) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func init() {
	proto.RegisterType((*ShieldedInput)(nil), "zsl.ShieldedInput")
	proto.RegisterType((*Note)(nil), "zsl.Note")
	proto.RegisterType((*ShieldedTransferRequest)(nil), "zsl.ShieldedTransferRequest")
	proto.RegisterType((*VerifyShieldedTransferRequest)(nil), "zsl.VerifyShieldedTransferRequest")
	proto.RegisterType((*ShieldedTransfer)(nil), "zsl.ShieldedTransfer")
	proto.RegisterType((*VerifyShieldingRequest)(nil), "zsl.VerifyShieldingRequest")
	proto.RegisterType((*Shielding)(nil), "zsl.Shielding")
	proto.RegisterType((*VerifyUnshieldingRequest)(nil), "zsl.VerifyUnshieldingRequest")
	proto.RegisterType((*Unshielding)(nil), "zsl.Unshielding")
	proto.RegisterType((*ZAddress)(nil), "zsl.ZAddress")
	proto.RegisterType((*Bytes)(nil), "zsl.Bytes")
	proto.RegisterType((*Result)(nil), "zsl.Result")
	proto.RegisterType((*Void)(nil), "zsl.Void")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ZSLBox service

type ZSLBoxClient interface {
	// CreateShielding computes a zkSNARK and a note commitment for given note.
	// Also returns a sendNullifier to ensure note.Rho (random) is unique
	CreateShielding(ctx context.Context, in *Note, opts ...grpc.CallOption) (*Shielding, error)
	// CreateUnshielding computes a zkSNARK, nullifiers for given input, using Unshielding circuit
	CreateUnshielding(ctx context.Context, in *ShieldedInput, opts ...grpc.CallOption) (*Unshielding, error)
	// CreateShieldedTransfer takes 2 notes as inputs (known Sk) and 2 desired output notes.
	// It returns the zkSNARK, the spend nullifiers for the inputs, and the commitments & send nullifiers for outputs
	CreateShieldedTransfer(ctx context.Context, in *ShieldedTransferRequest, opts ...grpc.CallOption) (*ShieldedTransfer, error)
	// VerifyShielding ensures that the provided Shielding proof is valid. It takes as input the zkSNARK,
	// the send nullifier, commitment and value of the shielded note.
	VerifyShielding(ctx context.Context, in *VerifyShieldingRequest, opts ...grpc.CallOption) (*Result, error)
	// VerifyUnshielding ensures that the provided Unshielding proof is valid. It takes as input the zkSNARK,
	// the spend nullifier, the tree root and value of the shielded note.
	VerifyUnshielding(ctx context.Context, in *VerifyUnshieldingRequest, opts ...grpc.CallOption) (*Result, error)
	// VerifyShieldedTransfer ensures that the provided shielded transfer proof is valid.
	// It takes as input the zkSNARK, treeRoot, spend nullifiers for inputs and send nullifiers & commitments
	// for outputs
	VerifyShieldedTransfer(ctx context.Context, in *VerifyShieldedTransferRequest, opts ...grpc.CallOption) (*Result, error)
	// GetCommitment returns SHA256(note.Rho || note.Pk || note.Value)
	// where note.Value is in little endian byte order
	GetCommitment(ctx context.Context, in *Note, opts ...grpc.CallOption) (*Bytes, error)
	// GetSendNullifier returns SHA256(0x00 || note.Rho)
	GetSendNullifier(ctx context.Context, in *Note, opts ...grpc.CallOption) (*Bytes, error)
	// GetSpendNullifier returns SHA256(0x01 || shieldedInput.Rho || shieldedInput.Sk)
	GetSpendNullifier(ctx context.Context, in *ShieldedInput, opts ...grpc.CallOption) (*Bytes, error)
	// GetNewAddress returns a tuple (Pk, Sk) where Pk is the paying (public) key and Sk is the secret key
	GetNewAddress(ctx context.Context, in *Void, opts ...grpc.CallOption) (*ZAddress, error)
	// Sha256Compress applies SHA-256 to one input block, excluding the padding step specified in [NIST2015, Section 5.1]
	Sha256Compress(ctx context.Context, in *Bytes, opts ...grpc.CallOption) (*Bytes, error)
}

type zSLBoxClient struct {
	cc *grpc.ClientConn
}

func NewZSLBoxClient(cc *grpc.ClientConn) ZSLBoxClient {
	return &zSLBoxClient{cc}
}

func (c *zSLBoxClient) CreateShielding(ctx context.Context, in *Note, opts ...grpc.CallOption) (*Shielding, error) {
	out := new(Shielding)
	err := grpc.Invoke(ctx, "/zsl.ZSLBox/CreateShielding", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zSLBoxClient) CreateUnshielding(ctx context.Context, in *ShieldedInput, opts ...grpc.CallOption) (*Unshielding, error) {
	out := new(Unshielding)
	err := grpc.Invoke(ctx, "/zsl.ZSLBox/CreateUnshielding", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zSLBoxClient) CreateShieldedTransfer(ctx context.Context, in *ShieldedTransferRequest, opts ...grpc.CallOption) (*ShieldedTransfer, error) {
	out := new(ShieldedTransfer)
	err := grpc.Invoke(ctx, "/zsl.ZSLBox/CreateShieldedTransfer", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zSLBoxClient) VerifyShielding(ctx context.Context, in *VerifyShieldingRequest, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := grpc.Invoke(ctx, "/zsl.ZSLBox/VerifyShielding", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zSLBoxClient) VerifyUnshielding(ctx context.Context, in *VerifyUnshieldingRequest, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := grpc.Invoke(ctx, "/zsl.ZSLBox/VerifyUnshielding", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zSLBoxClient) VerifyShieldedTransfer(ctx context.Context, in *VerifyShieldedTransferRequest, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := grpc.Invoke(ctx, "/zsl.ZSLBox/VerifyShieldedTransfer", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zSLBoxClient) GetCommitment(ctx context.Context, in *Note, opts ...grpc.CallOption) (*Bytes, error) {
	out := new(Bytes)
	err := grpc.Invoke(ctx, "/zsl.ZSLBox/GetCommitment", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zSLBoxClient) GetSendNullifier(ctx context.Context, in *Note, opts ...grpc.CallOption) (*Bytes, error) {
	out := new(Bytes)
	err := grpc.Invoke(ctx, "/zsl.ZSLBox/GetSendNullifier", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zSLBoxClient) GetSpendNullifier(ctx context.Context, in *ShieldedInput, opts ...grpc.CallOption) (*Bytes, error) {
	out := new(Bytes)
	err := grpc.Invoke(ctx, "/zsl.ZSLBox/GetSpendNullifier", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zSLBoxClient) GetNewAddress(ctx context.Context, in *Void, opts ...grpc.CallOption) (*ZAddress, error) {
	out := new(ZAddress)
	err := grpc.Invoke(ctx, "/zsl.ZSLBox/GetNewAddress", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zSLBoxClient) Sha256Compress(ctx context.Context, in *Bytes, opts ...grpc.CallOption) (*Bytes, error) {
	out := new(Bytes)
	err := grpc.Invoke(ctx, "/zsl.ZSLBox/Sha256Compress", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ZSLBox service

type ZSLBoxServer interface {
	// CreateShielding computes a zkSNARK and a note commitment for given note.
	// Also returns a sendNullifier to ensure note.Rho (random) is unique
	CreateShielding(context.Context, *Note) (*Shielding, error)
	// CreateUnshielding computes a zkSNARK, nullifiers for given input, using Unshielding circuit
	CreateUnshielding(context.Context, *ShieldedInput) (*Unshielding, error)
	// CreateShieldedTransfer takes 2 notes as inputs (known Sk) and 2 desired output notes.
	// It returns the zkSNARK, the spend nullifiers for the inputs, and the commitments & send nullifiers for outputs
	CreateShieldedTransfer(context.Context, *ShieldedTransferRequest) (*ShieldedTransfer, error)
	// VerifyShielding ensures that the provided Shielding proof is valid. It takes as input the zkSNARK,
	// the send nullifier, commitment and value of the shielded note.
	VerifyShielding(context.Context, *VerifyShieldingRequest) (*Result, error)
	// VerifyUnshielding ensures that the provided Unshielding proof is valid. It takes as input the zkSNARK,
	// the spend nullifier, the tree root and value of the shielded note.
	VerifyUnshielding(context.Context, *VerifyUnshieldingRequest) (*Result, error)
	// VerifyShieldedTransfer ensures that the provided shielded transfer proof is valid.
	// It takes as input the zkSNARK, treeRoot, spend nullifiers for inputs and send nullifiers & commitments
	// for outputs
	VerifyShieldedTransfer(context.Context, *VerifyShieldedTransferRequest) (*Result, error)
	// GetCommitment returns SHA256(note.Rho || note.Pk || note.Value)
	// where note.Value is in little endian byte order
	GetCommitment(context.Context, *Note) (*Bytes, error)
	// GetSendNullifier returns SHA256(0x00 || note.Rho)
	GetSendNullifier(context.Context, *Note) (*Bytes, error)
	// GetSpendNullifier returns SHA256(0x01 || shieldedInput.Rho || shieldedInput.Sk)
	GetSpendNullifier(context.Context, *ShieldedInput) (*Bytes, error)
	// GetNewAddress returns a tuple (Pk, Sk) where Pk is the paying (public) key and Sk is the secret key
	GetNewAddress(context.Context, *Void) (*ZAddress, error)
	// Sha256Compress applies SHA-256 to one input block, excluding the padding step specified in [NIST2015, Section 5.1]
	Sha256Compress(context.Context, *Bytes) (*Bytes, error)
}

func RegisterZSLBoxServer(s *grpc.Server, srv ZSLBoxServer) {
	s.RegisterService(&_ZSLBox_serviceDesc, srv)
}

func _ZSLBox_CreateShielding_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Note)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZSLBoxServer).CreateShielding(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zsl.ZSLBox/CreateShielding",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZSLBoxServer).CreateShielding(ctx, req.(*Note))
	}
	return interceptor(ctx, in, info, handler)
}

func _ZSLBox_CreateUnshielding_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShieldedInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZSLBoxServer).CreateUnshielding(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zsl.ZSLBox/CreateUnshielding",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZSLBoxServer).CreateUnshielding(ctx, req.(*ShieldedInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _ZSLBox_CreateShieldedTransfer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShieldedTransferRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZSLBoxServer).CreateShieldedTransfer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zsl.ZSLBox/CreateShieldedTransfer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZSLBoxServer).CreateShieldedTransfer(ctx, req.(*ShieldedTransferRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ZSLBox_VerifyShielding_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyShieldingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZSLBoxServer).VerifyShielding(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zsl.ZSLBox/VerifyShielding",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZSLBoxServer).VerifyShielding(ctx, req.(*VerifyShieldingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ZSLBox_VerifyUnshielding_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyUnshieldingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZSLBoxServer).VerifyUnshielding(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zsl.ZSLBox/VerifyUnshielding",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZSLBoxServer).VerifyUnshielding(ctx, req.(*VerifyUnshieldingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ZSLBox_VerifyShieldedTransfer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyShieldedTransferRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZSLBoxServer).VerifyShieldedTransfer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zsl.ZSLBox/VerifyShieldedTransfer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZSLBoxServer).VerifyShieldedTransfer(ctx, req.(*VerifyShieldedTransferRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ZSLBox_GetCommitment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Note)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZSLBoxServer).GetCommitment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zsl.ZSLBox/GetCommitment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZSLBoxServer).GetCommitment(ctx, req.(*Note))
	}
	return interceptor(ctx, in, info, handler)
}

func _ZSLBox_GetSendNullifier_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Note)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZSLBoxServer).GetSendNullifier(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zsl.ZSLBox/GetSendNullifier",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZSLBoxServer).GetSendNullifier(ctx, req.(*Note))
	}
	return interceptor(ctx, in, info, handler)
}

func _ZSLBox_GetSpendNullifier_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShieldedInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZSLBoxServer).GetSpendNullifier(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zsl.ZSLBox/GetSpendNullifier",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZSLBoxServer).GetSpendNullifier(ctx, req.(*ShieldedInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _ZSLBox_GetNewAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZSLBoxServer).GetNewAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zsl.ZSLBox/GetNewAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZSLBoxServer).GetNewAddress(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _ZSLBox_Sha256Compress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Bytes)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZSLBoxServer).Sha256Compress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zsl.ZSLBox/Sha256Compress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZSLBoxServer).Sha256Compress(ctx, req.(*Bytes))
	}
	return interceptor(ctx, in, info, handler)
}

var _ZSLBox_serviceDesc = grpc.ServiceDesc{
	ServiceName: "zsl.ZSLBox",
	HandlerType: (*ZSLBoxServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateShielding",
			Handler:    _ZSLBox_CreateShielding_Handler,
		},
		{
			MethodName: "CreateUnshielding",
			Handler:    _ZSLBox_CreateUnshielding_Handler,
		},
		{
			MethodName: "CreateShieldedTransfer",
			Handler:    _ZSLBox_CreateShieldedTransfer_Handler,
		},
		{
			MethodName: "VerifyShielding",
			Handler:    _ZSLBox_VerifyShielding_Handler,
		},
		{
			MethodName: "VerifyUnshielding",
			Handler:    _ZSLBox_VerifyUnshielding_Handler,
		},
		{
			MethodName: "VerifyShieldedTransfer",
			Handler:    _ZSLBox_VerifyShieldedTransfer_Handler,
		},
		{
			MethodName: "GetCommitment",
			Handler:    _ZSLBox_GetCommitment_Handler,
		},
		{
			MethodName: "GetSendNullifier",
			Handler:    _ZSLBox_GetSendNullifier_Handler,
		},
		{
			MethodName: "GetSpendNullifier",
			Handler:    _ZSLBox_GetSpendNullifier_Handler,
		},
		{
			MethodName: "GetNewAddress",
			Handler:    _ZSLBox_GetNewAddress_Handler,
		},
		{
			MethodName: "Sha256Compress",
			Handler:    _ZSLBox_Sha256Compress_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "zslbox.proto",
}

func init() { proto.RegisterFile("zslbox.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 681 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x55, 0x5d, 0x4f, 0xd4, 0x40,
	0x14, 0x4d, 0xb7, 0x65, 0x61, 0xef, 0x7e, 0xb0, 0x4c, 0x14, 0x9b, 0x15, 0xcc, 0xa6, 0x1a, 0xb2,
	0x12, 0xc2, 0xc3, 0x12, 0x4d, 0xd4, 0x44, 0x03, 0x3c, 0x10, 0x12, 0x25, 0x66, 0x56, 0x79, 0x20,
	0xbe, 0x14, 0x3b, 0xb0, 0x95, 0x6e, 0xa7, 0x74, 0xa6, 0x0a, 0xfb, 0x60, 0xe2, 0xab, 0xbf, 0xc1,
	0xdf, 0xe7, 0xef, 0x30, 0x33, 0x6d, 0xb7, 0x33, 0x6d, 0x49, 0x48, 0x7c, 0x9b, 0x7b, 0xe7, 0xec,
	0xbd, 0xf7, 0x9c, 0x39, 0xb7, 0x0b, 0x9d, 0x39, 0x0b, 0xce, 0xe9, 0xcd, 0x6e, 0x14, 0x53, 0x4e,
	0x91, 0x39, 0x67, 0x81, 0xf3, 0xcb, 0x80, 0xee, 0x64, 0xea, 0x93, 0xc0, 0x23, 0xde, 0x71, 0x18,
	0x25, 0x1c, 0xf5, 0xa0, 0xc1, 0xae, 0x6c, 0x63, 0x68, 0x8c, 0x3a, 0xb8, 0xc1, 0xae, 0x50, 0x1f,
	0xcc, 0x78, 0x4a, 0xed, 0x86, 0x4c, 0x88, 0x23, 0x7a, 0x00, 0x4b, 0xdf, 0xdd, 0x20, 0x21, 0xb6,
	0x39, 0x34, 0x46, 0x16, 0x4e, 0x03, 0xb4, 0x01, 0x2d, 0x1e, 0x13, 0x72, 0x1c, 0x7a, 0xe4, 0xc6,
	0xb6, 0xe4, 0x4d, 0x91, 0x40, 0x03, 0x58, 0x11, 0xc1, 0x47, 0x97, 0x4f, 0xed, 0xa5, 0xa1, 0x39,
	0xea, 0xe0, 0x45, 0xec, 0xbc, 0x05, 0xeb, 0x84, 0x72, 0x22, 0x3a, 0x47, 0x8b, 0xce, 0xd1, 0xbd,
	0x3b, 0x3b, 0xdf, 0xe0, 0x51, 0x4e, 0xe1, 0x53, 0xec, 0x86, 0xec, 0x82, 0xc4, 0x98, 0x5c, 0x27,
	0x84, 0x71, 0xb4, 0x0d, 0x4d, 0x5f, 0xb0, 0x62, 0xb6, 0x31, 0x34, 0x47, 0xed, 0x31, 0xda, 0x9d,
	0xb3, 0x60, 0x57, 0x23, 0x8c, 0x33, 0x04, 0x7a, 0x0a, 0xcb, 0x34, 0xe1, 0x12, 0xdc, 0x90, 0xe0,
	0x96, 0x04, 0x8b, 0xd1, 0x70, 0x7e, 0xe3, 0xfc, 0x84, 0xcd, 0x53, 0x12, 0xfb, 0x17, 0xb7, 0x77,
	0x75, 0xdc, 0x87, 0x3e, 0x2b, 0x5d, 0x49, 0x4a, 0xed, 0xf1, 0x43, 0xad, 0xf7, 0xe2, 0x77, 0x15,
	0x78, 0xae, 0x15, 0xa6, 0x94, 0x67, 0xe4, 0x17, 0xb1, 0xf3, 0xc7, 0x80, 0x7e, 0xb9, 0x84, 0x90,
	0x85, 0x85, 0x6e, 0x9c, 0x6b, 0x97, 0x06, 0x68, 0x04, 0xab, 0x2c, 0x22, 0xa1, 0x77, 0x92, 0x04,
	0x81, 0x7f, 0xe1, 0x93, 0x38, 0xe5, 0xd5, 0xc1, 0xe5, 0x34, 0xda, 0x82, 0x1e, 0xd3, 0x81, 0xa6,
	0x04, 0x96, 0xb2, 0x68, 0x08, 0xed, 0xaf, 0x74, 0x36, 0xf3, 0xf9, 0x8c, 0x84, 0x9c, 0xd9, 0x96,
	0x04, 0xa9, 0x29, 0xe7, 0x0b, 0xac, 0xab, 0xf2, 0xf8, 0xe1, 0x65, 0xae, 0xcb, 0x0e, 0xb4, 0x58,
	0x9e, 0xcb, 0x04, 0xe9, 0x29, 0x82, 0x08, 0x64, 0x01, 0x28, 0x1e, 0xba, 0xa1, 0x3e, 0xf4, 0x25,
	0xb4, 0x26, 0x2a, 0xa4, 0x86, 0xf4, 0x13, 0x80, 0x62, 0x9e, 0x4c, 0x3d, 0x25, 0x83, 0x9e, 0x41,
	0x57, 0x23, 0x25, 0x9d, 0xd4, 0xc1, 0x7a, 0xd2, 0xf9, 0x6d, 0x80, 0x9d, 0xf2, 0xf8, 0x1c, 0xb2,
	0x32, 0x93, 0xfa, 0xc6, 0x42, 0x43, 0x4d, 0xd6, 0xac, 0x79, 0x29, 0xab, 0x3d, 0xae, 0xa9, 0x3f,
	0x6e, 0xc1, 0xda, 0x52, 0x59, 0x5f, 0x43, 0x5b, 0x99, 0xe2, 0x3f, 0xdb, 0xdf, 0x8f, 0xff, 0x36,
	0xac, 0x9c, 0xed, 0x7b, 0x5e, 0x4c, 0x18, 0xab, 0x7c, 0x0f, 0xd2, 0x2d, 0x6d, 0xe4, 0x5b, 0xea,
	0x6c, 0xc2, 0xd2, 0xc1, 0x2d, 0x27, 0x4c, 0x0c, 0x76, 0x2e, 0x0e, 0xf9, 0x60, 0x32, 0x70, 0x5e,
	0x43, 0x13, 0x13, 0x96, 0x04, 0x1c, 0xad, 0x43, 0x33, 0x96, 0x27, 0x09, 0x58, 0xc1, 0x59, 0x84,
	0x6c, 0x58, 0x9e, 0x11, 0xc6, 0xdc, 0xcb, 0xf4, 0xb5, 0x5b, 0x38, 0x0f, 0x9d, 0x26, 0x58, 0xa7,
	0xd4, 0xf7, 0xc6, 0x7f, 0x2d, 0x68, 0x9e, 0x4d, 0xde, 0x1f, 0xd0, 0x1b, 0xb4, 0x03, 0xab, 0x87,
	0x31, 0x71, 0x39, 0x29, 0x8c, 0x50, 0xac, 0xe9, 0xa0, 0xe4, 0x28, 0xf4, 0x0a, 0xd6, 0x52, 0xb4,
	0x2a, 0x60, 0xcd, 0x37, 0x60, 0xd0, 0x97, 0x39, 0x15, 0xf5, 0x01, 0xd6, 0xd5, 0x46, 0xca, 0xb6,
	0x6d, 0xd4, 0xef, 0x71, 0xea, 0x8e, 0x41, 0xfd, 0x96, 0xa3, 0x37, 0xb0, 0x5a, 0x5a, 0x0c, 0xf4,
	0x58, 0x22, 0xeb, 0xd7, 0x65, 0xd0, 0x96, 0x97, 0x99, 0x72, 0xef, 0x60, 0xad, 0xe2, 0x46, 0xb4,
	0xa9, 0xfc, 0xbc, 0xea, 0x52, 0xbd, 0xc0, 0xb1, 0xbe, 0x96, 0xca, 0x5c, 0x4e, 0x65, 0x88, 0x2a,
	0x25, 0xad, 0xd4, 0x16, 0x74, 0x8f, 0x08, 0x3f, 0x2c, 0x36, 0x4a, 0x91, 0x1f, 0xe4, 0x31, 0x75,
	0xc3, 0x73, 0xe8, 0x1f, 0x11, 0x3e, 0xd1, 0xcc, 0x77, 0x07, 0x74, 0x0f, 0xd6, 0x04, 0x54, 0x37,
	0x6a, 0xdd, 0x2b, 0xe9, 0xf5, 0xc5, 0x1c, 0x27, 0xe4, 0x47, 0xee, 0xd3, 0xb4, 0xb8, 0xf0, 0xcb,
	0xa0, 0x2b, 0x8f, 0x0b, 0x07, 0x8f, 0xa0, 0x37, 0x99, 0xba, 0xe3, 0x17, 0x2f, 0x0f, 0xe9, 0x2c,
	0x92, 0x19, 0xa5, 0x90, 0x5a, 0xf4, 0xbc, 0x29, 0xff, 0x19, 0xf7, 0xfe, 0x05, 0x00, 0x00, 0xff,
	0xff, 0x45, 0xb5, 0xba, 0x73, 0x29, 0x07, 0x00, 0x00,
}
